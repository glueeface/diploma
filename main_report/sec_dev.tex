\section{РАЗРАБОТКА ПРОГРАММНЫХ МОДУЛЕЙ}
\label{sec:dev}

В разделе разработки программных модулей описана разработка ключевых алгоритмов для данного дипломного проекта.

%Разработка программных модулей – аналог разработки принципиальной схемы аппаратного дипломного проекта.
%В этом разделе подробно описываются уже внутренние алгоритмы ключевых процедур и функций с разбиением на отдельные подразделы.
%Здесь  же  описывается  реализация  наиболее  интересных алгоритмов, например, алгоритмов шифрования.
%Данный раздел может сопровождать чертежи схем программ и содержать ссылки на них.


\subsection{Алгоритм обработки запроса}
Как изображено на схеме данных \dataScheme\ и было упомянуто ранее, разрабатываемая система условно делится на две части:
основной микросервис, написанный с использованием Django и Django Rest Framework,
и микросервис, написанный с использованием FastAPI, ответственный за парсинг и статистику.

В результате разработки системы оказалось, что наибольший интерес представляют алгоритмы обработки запросов на стороне основного микросервиса.

На блок-схеме алгоритма \blockScheme\ изображен алгоритм обработки запроса после его преобразования WSGI-сервером.
Описанный алгоритм работает с принятым пакетом, который представлен объектом класса~\lstinline{WSGIRequest}.
Перед тем, как запрос будет направлен на один из эндпоинтов, ему необходимо пройти механизм аунтентификации, который описан в классе
~\lstinline{JWTAuthenticationMiddleware} в файле middleware.py.
В обработанном объекте класса~\lstinline{WSGIRequest} содержится информация,
которая требуется при обработке запроса каждым из классов представления.

\subsection{Алгоритм работы модуля аунтентификации}

Распишем данный алгоритм по шагам:
\begin{enumerate_step}
    \item Начало алгоритма.
    \item Загрузить переменные окружения при помощи вызова функции~\lstinline{load_dotenv}.
    \item Создать локальную переменную~\lstinline{JWT_SECRET_KEY} для сохранения в ней значения переменной окружения~\lstinline{JWT_SECRET_KEY}.
    \item Инициализируем глобальную переменную~\lstinline{JWT_SECRET_KEY} при помощи получения значения по ключу из словаря~\lstinline{os.environ}.

    \item Создать локальную переменную~\lstinline{jwt_token} для сохранения в ней значения заголовка~\lstinline{AUTHORIZATION}.
    \item Инициализируем локальную переменную \lstinline{jwt_token} значением заголовка~\lstinline{AUTHORIZATION} путём вызова метода~\lstinline{request.headers.get}.
    \item Проверить значение переменной~\lstinline{jwt_token}.
    Если оно инициализированно значением~\lstinline{None}, то перейти к шагу~\ref{itm:dev:anonimous}.
    \item Войти в блок~\lstinline{try}.
    \item Создать локальную переменную~\lstinline{payload} для сохранения в ней декодированного значения переменной~\lstinline{jwt_token}.
    \item Инициализируем локальную переменную~\lstinline{payload} декодированным значением переменной~\lstinline{jwt_token} путём вызова метода~\lstinline{jwt.decode}.
    Если в процессе декодирования возникла ошибка~\lstinline{jwt.ExpiredSignatureError}, то перейти к шагу~\ref{itm:dev:exp-token-error}.
    Если в процессе декодирования возникла одна из ошибкок~\lstinline{jwt.DecodeError} или~\lstinline{jwt.InvalidTokenError}, то перейти к шагу~\ref{itm:dev:inv-token-error}.
    \item Установить значение~\lstinline{try}.

    \item\label{itm:dev:exp-token-error} Завершение алгоритма путем возврата объекта класса~\lstinline{HttpResponse},
    установив его значения~\lstinline{content} и~\lstinline{status} в значения~\lstinline{"Token has expired"} и~\lstinline{HTTP_401_UNAUTHORIZED} соответственно .
%    Конец алгоритма

    \item\label{itm:dev:inv-token-error} Установить значение переменной~\lstinline{request.user} в значение ~\lstinline{AnonymousUser} и завершение алгоритма.
    \item\label{itm:dev:anonimous} Установить значение переменной~\lstinline{request.user} в значение~\lstinline{AnonymousUser}.
    \item Конец алгоритма.
\end{enumerate_step}

\subsection{Алгоритм работы \moduleAutoTrading}
\label{subsec:dev:moduleautotrading}

Данный алгоритм разработан для того чтобы система могла производить операцию покупки или продажи, основываясь на
элементе автоматического оффера, созданного пользователем и хранящимся в СУБД PostgreSQL.
Так как данный алгоритм занимает одно из центральных мест в трейдинговой платформе, его необходимо рассмотреть подробно.
Данный алгоритм состоит из четырех подпрограмм, три из которых используются в алгоритме произведения ручных офферов.

Распишем данный алгоритм по шагам:
\begin{enumerate_step}
    \item Начало алгоритма.
    \item Создать локальную переменную~\lstinline{orders} для сохранения в ней значений активных офферов, хранящихся в базе данных.
    \item Выполнить инициализацию локальной переменной~\lstinline{orders} значениями активных офферов путём вызова метода~\lstinline{models.Order.objects.filter}.

    \item Создать локальную переменную~\lstinline{currencies} для сохранения в ней каждой из валют, находящихся в переменной~\lstinline{orders}.
    \item Выполнить итерацию по каждому элементу переменной~\lstinline{orders}, вызывая у каждого элемента метод~\lstinline{get_currency_name}.
    \item\label{itm:prep-for-set} Выполнить инициализацию переменной~\lstinline{currencies} уникальными значениями каждой из валют,
    полученных в~\ref{itm:prep-for-set} путем вызова метода~\lstinline{__init__} класса~\lstinline{set}.

    \item\label{itm:dev:auto-tr:currencies-iter} Начало цикла по переменной~\lstinline{currencies} объекта класса~\lstinline{list}
    с объектом итерации~\lstinline{currency_name} класса ~\lstinline{str}.
    \item Создать локальную переменную~\lstinline{currency_orders} для сохранения в ней значений активных офферов с валютой,
    хранящейся в переменной~\lstinline{currency_name}.
    \item Выполнить инициализацию локальной переменной~\lstinline{currency_orders} значениями активных офферов с валютой,
    хранящейся в переменной~\lstinline{currency_name}, путём вызова метода~\lstinline{models.Order.objects.filter} с параметром~\lstinline{currency__name}.
    \item Если длина значения переменной~\lstinline{currency_orders} равна нулю -- перейти к шагу~\ref{itm:dev:auto-tr:currencies-iter}.

    \item Войти в блок~\lstinline{try}.
    \item Создать локальную переменную~\lstinline{currency_rate} для сохранения в ней текущего курса валюты,
    определяемой переменной итерации~\lstinline{currency_name}, хранящихся в базе данных.

    \item Выполнить инициализацию локальной переменной~\lstinline{currency_rate} текущего курса валюты,
    определяемой переменной итерации~\lstinline{currency_name}, путём вызова метода~\lstinline{get_currency_rate} у записи из СУБД,
    которая будет получена путём вызова метода~\lstinline{Currency.objects.get} и передачи в него значения переменной~\lstinline{currency_name}.
    Если в процессе выполнения данного шага возникла ошибка -- перейти к шагу~\ref{itm:dev:auto-tr:currencies-iter}.
    \item Выйти из блока~\lstinline{try}.

    \item\label{itm:dev:auto-tr:order-iter} Начало цикла по переменной~\lstinline{currency_orders} объекта класса~\lstinline{list}
    с переменной итерации~\lstinline{order} класса~\lstinline{Order}.
    \item Выполнить вызов функции~\lstinline{create_transaction} с передачей значений переменных~\lstinline{order} и~\lstinline{currency_rate}.
    Если возвращаемое значение функции~\lstinline{create_transaction} равно~\lstinline{False} -- перейти к шагу~\ref{itm:dev:auto-tr:order-iter}.
    \item Инициализировать переменную~\lstinline{order} обновленной информацией из базы данных
    путём вызова у объекта~\lstinline{order} метода~\lstinline{refresh_from_db}.

    \item Создать локальную переменную~\lstinline{user} для сохранения в ней объекта класса~\lstinline{User}, которому принадлежит
    выполненный оффер, хранящийся в переменной~\lstinline{order}.
    \item Инициализировать переменную~\lstinline{order} объекта класса~\lstinline{User}, которому принадлежит выполненный оффер,
    хранящийся в переменной~\lstinline{order}, путём получения у объекта~\lstinline{order} аргумента~\lstinline{user}.
    \item Создать объект класса~\lstinline{str} с именем~\lstinline{subject} и инициализировать его значением~\lstinline{"Successful order"}.
    \item Создать объект класса~\lstinline{str} с именем~\lstinline{message} и инициализировать его с использованием возвращаемого значения
    метода~\lstinline{get_full_name}, аргумента~\lstinline{cash} объекта~\lstinline{user} и аргумента~\lstinline{id} объекта~\lstinline{order}.

    \item Создать объект класса~\lstinline{list} с именем~\lstinline{recipient_list} и
    инициализировать его аргументом~\lstinline{email} объекта~\lstinline{user}.
    \item Выполнить вызов функции~\lstinline{send_smtp_email} с передачей значений
    переменных~\lstinline{subject},~\lstinline{message} и~\lstinline{recipient_list}.

    \item Если переменная~\lstinline{currency_orders} еще имеет значения,
    которые не участвовали при итерировании, перейти к шагу~\ref{itm:dev:auto-tr:order-iter}.
    \item Конец цикла по переменной~\lstinline{currency_orders}.

    \item Если переменная~\lstinline{currencies} еще имеет значения,
    которые не участвовали при итерировании, перейти к шагу~\ref{itm:dev:auto-tr:currencies-iter}.
    \item Конец цикла по переменной~\lstinline{currencies}.

    \item Конец алгоритма.
\end{enumerate_step}

Так как данный алгоритм использует внутри себя 4 подпрограммы, то слудет описять и их алгоритмы работы.

\subsubsection{Алгоритм работы подпрограммы \lstinline{create_transaction}}

\begin{enumerate_step}
    \item Начало алгоритма.

%    \item Получить значения, переданные в функцию значения.
    \item Создать локальные переменные~\lstinline{is_valid} и~\lstinline{action} классов ~\lstinline{bool} и ~\lstinline{int} соответственно.
    \item Вызвать функцию~\lstinline{is_valid_transaction} передав ей параметрами объекты~\lstinline{order} и~\lstinline{rate}.
    \item Выполнить инициализацию локальных переменных~\lstinline{is_valid} и~\lstinline{action}
    путём присвоения им возвращаемых значений функции~\lstinline{is_valid_transaction}.
    \item Если значение переменной~\lstinline{is_valid} отлично от значения~\lstinline{True}, вернуть значение~\lstinline{False} и
    перейти к шагу~\ref{itm:dev:create_transaction:end}.

    \item Создать локальную переменную~\lstinline{transaction} класса~\lstinline{Transaction} и инициализировать её используя переменную
    ~\lstinline{rate} и аргументы~\lstinline{count},~\lstinline{user} и~\lstinline{currency} объекта~\lstinline{order}.
    \item Сохранить объект~\lstinline{transaction} в СУБД postgreSQL, вызвав у него метод~\lstinline{save}.

    \item Изменить статус объекта~\lstinline{order}, установив аргумент~\lstinline{is_active} в значение~\lstinline{False}.
    \item Сохранить изменения объекта~\lstinline{order} в СУБД PostgreSQL, вызвав у объекта метод~\lstinline{save}.

    \item Изменить баланс пользователя путем высчитывания нового баланса на основании объектов
    ~\lstinline{rate},~\lstinline{rate} и аргумента~\lstinline{count} объекта~\lstinline{order} и его присвоения аргументу~\lstinline{order.user.cash}.
    \item Сохранить изменения объект~\lstinline{order.user} в СУБД postgreSQL, вызвав у объекта метод~\lstinline{save}.
    \item Вернуть значение~\lstinline{True}.

    \item\label{itm:dev:create_transaction:end} Конец алгоритма.
\end{enumerate_step}

\subsubsection{Алгоритм работы подпрограммы \lstinline{is_valid_transaction}}

\begin{enumerate_step}
    \item Начало алгоритма.

    \item Сравнить значение аргумента~\lstinline{action} объекта~\lstinline{order} со значением~\lstinline{"BUY"}.
    Если значения не совпадают, то перейти к шагу~\ref{itm:dev:is_valid_transaction:elif}.
    \item Удостовериться в том, что у пользователя достаточно средств на балансе, чтобы произвести покупку и
    текущий курс валюты для покупки ниже или равен установленному пользователем курсу в оффере.
    Если оба условия выполняются, вернуть объекты классов~\lstinline{bool} и~\lstinline{int} со значениями~\lstinline{True} и~\lstinline{-1} соответственно.
    Перейти к шагу~\ref{itm:dev:is_valid_transaction:end}.

    \item\label{itm:dev:is_valid_transaction:elif}
    Сравнить значение аргумента~\lstinline{action} объекта~\lstinline{order} со значением~\lstinline{"SELL"}.
    Если значения не совпадают, перейти к шагу~\ref{itm:dev:is_valid_transaction:end-with-error}.

    \item Создать локальную переменную~\lstinline{bag} класса~\lstinline{dict}.
    \item Вызвать функцию~\lstinline{get_bag} передав ей параметрами объекты класса~\lstinline{Transaction},
    связанные с аргументом~\lstinline{user} объекта~\lstinline{order}.
    \item Выполнить инициализацию локальной переменной~\lstinline{bag}
    путём присвоения ей возвращаемого значения функции~\lstinline{get_bag}.

    \item Войти в блок~\lstinline{try}.
    \item Удостовериться в том, что у пользователя достаточно средств на балансе, чтобы произвести продажу и
    текущий курс валюты для продажи больше или равен установленному пользователем курсу в оффере.
    Если значения не совпадают, перейти к шагу~\ref{itm:dev:is_valid_transaction:end-with-error}.
    \item Вернуть объекты классов~\lstinline{bool} и~\lstinline{int} со значениями~\lstinline{True} и~\lstinline{1} соответственно.
    \item Перейти к шагу~\ref{itm:dev:is_valid_transaction:end}.

    \item\label{itm:dev:is_valid_transaction:end-with-error}
    Вернуть объекты классов~\lstinline{bool} и~\lstinline{int} со значениями~\lstinline{False} и~\lstinline{0} соответственно.
    \item\label{itm:dev:is_valid_transaction:end} Конец алгоритма.
\end{enumerate_step}

\subsubsection{Алгоритм работы подпрограммы \lstinline{get_bag}}

\begin{enumerate_step}
    \item Начало алгоритма.

    \item Создать локальную переменную~\lstinline{currencies} для сохранения в ней каждой из валют, находящихся в переменной~\lstinline{queryset}.
    \item\label{itm:dev:get_bag:prep-for-set} Выполнить итерацию по каждому элементу переменной~\lstinline{queryset},
    вызывая у каждого элемента метод~\lstinline{get_currency_name}.
    \item Выполнить инициализацию переменной~\lstinline{currencies} уникальными значениями каждой из валют,
    полученных в шаге~\ref{itm:prep-for-set} путем вызова метода~\lstinline{__init__} класса~\lstinline{set}.

    \item Создать локальную переменную~\lstinline{bag} класса~\lstinline{dict}.

    \item\label{itm:dev:get_bag:currencies-iter}
    Начало цикла по переменной~\lstinline{currencies} объекта класса~\lstinline{list}
    с объектом итерации~\lstinline{currency_name} класса~\lstinline{str}.
    \item Добавить элемент в объект~\lstinline{bag} с ключем~\lstinline{currency_name}.
    Значение инициализировать путем вызова агрегирующей функции, которая будет выполнена на стороне базы данных.

    \item Если переменная~\lstinline{currencies} еще имеет значения,
    которые не участвовали при итерировании, перейти к шагу~\ref{itm:dev:get_bag:currencies-iter}.
    \item Конец цикла по переменной~\lstinline{currencies}.

    \item Вернуть значение локальной переменной~\lstinline{bag} класса~\lstinline{dict}.

    \item Конец алгоритма.
\end{enumerate_step}

%    \item Проверить, что строка для разбора начинается с символа <<\{>>. При ошибке
%    перейти к шагу~\ref{i:algo2:nestingError}.
%    \item \label{i:algo2:for} Получить элемент строки.
%    \item Выделить память под новый элемент списка.
%    \item Выполнить проверку на выделенную память. Если память не выделилась, перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item Выполнить инициализацию вспомогательных переменных.
%    \item Проверить, что текущий элемент строки для разбора соответствует <<;>>. В случае успеха перейти к шагу~\ref{i:algo2:endOfVars}.
%    \item Вывести сообщение \texttt{Конец vars}.
%    \item Вызвать подпрограмму очистки информации о vars, которая была записана, и перейти к шагу~\ref{i:algo2:lastOper}.
%
%    \item \label{i:algo2:endOfVars} Выполнить проверку, что текущий элемент строки соответствует символу <<\{>>, при ошибочном варианте перейти к шагу~\ref{i:algo2:GSearch}.
%    \item Увеличить счетчик открывающихся скобок \lstinline{open}, который был объявлен и проинициализирован в шаге~\ref{i:algo2:createVariables}.
%    \item Вызывать подпрограмму очистки информации о vars, которая была записана, и перейти к шагу~\ref{i:algo2:for}.
%
%    \item \label{i:algo2:GSearch} Выполнить проверку, что текущий элемент строки не соответствует символу <<G>>. При успешном результате перейти к шагу~\ref{i:algo2:notG}.
%    \item Обнулить вспомогательную переменную \lstinline{j}, которая была объявлена в шаге~\ref{i:algo2:createVariables}.
%    \item Увеличить счетчик движения по строке.
%    % write cdc_type in temp buffer
%    \item \label{i:algo2:StartLoop1} Проверить, является ли текущий символ буквой и не последним в строке. Если ошибка, то перейти к шагу~\ref{i:algo2:AddLastSymbol1}.
%    \item Произвести переписывание значения символа в локальный буфер \lstinline{cdc_type}, который был выделен в шаге~\ref{i:algo2:createBuf}, перейти к шагу~\ref{i:algo2:StartLoop1}.
%    \item \label{i:algo2:AddLastSymbol1} Добавить в конец символ <<\textbackslash 0>>.
%    % checking if the prefix is a number
%    \item Выполнить проверку префикса во входной строке. Если символ не является числом, то перейти к шагу~\ref{i:algo2:errorVarsFormat}.
%    \item Обнулить вспомогательную переменную \lstinline{j}, которая была объявлена в шаге~\ref{i:algo2:createVariables}.
%    % saving prefix to the buffer
%    \item \label{i:algo2:StartLoop2} Проверить, что текущий символ не является символом <<;>>,
%    <<.>> и не последний в строке. Если ошибка, то перейти к шагу~\ref{i:algo2:AddLastSymbol2}.
%    \item Произвести переписывание значения символа в локальный буфер \lstinline{prefix}, который был выделен в шаге~\ref{i:algo2:createBuf}, перейти к шагу~\ref{i:algo2:StartLoop2}.
%    \item \label{i:algo2:AddLastSymbol2} Добавляем в конец символ <<\textbackslash 0>>.
%    \item Увеличить счетчик движения по строке.
%    % checking that the first element of the da_name is a letter
%    \item Выполнить проверку, что первый элемент параметра \lstinline{da_name} во входной строку является буквой. При ошибке перейти к шагу~\ref{i:algo2:errorVarsType}.
%    \item Обнулить вспомогательную переменную \lstinline{j}, которая была объявлена в шаге~\ref{i:algo2:createVariables}.
%
%    \item \label{i:algo2:StartLoop3} Проверить, что текущий символ не является символом <<;>> и не последний в строке. Если ошибка, то перейти к шагу~\ref{i:algo2:lastLetter1}.
%    \item Выполнить проверку, что текущий символ является буквой. Если ошибка, то перейти к шагу~\ref{i:algo2:lastLetter}.
%    \item Произвести переписывание символа в локальный буфер \lstinline{da_name}, который был выделен в шаге~\ref{i:algo2:createBuf}, перейти к шагу~\ref{i:algo2:StartLoop3}.
%    \item \label{i:algo2:lastLetter} Вывести сообщение \texttt{Последний символ}.
%    \item \label{i:algo2:lastLetter1} Добавить в конец буфера \lstinline{da_name} символ <<\textbackslash 0>>.
%    % checking that the next character is required <<,'
%    \item Выполнить проверку, что текущий элемент строки соответствует не символу <<,>>. При успешном результате перейти к шагу~\ref{i:algo2:invalidVarsFormat}.
%    \item Увеличить счетчик движения по строке.
%    % checking that the next character is required <<\{'
%    \item Проверить, что текущий элемент строки не соответствует символу <<\{>>. В случае успеха перейти к шагу~\ref{i:algo2:nestingError1}.
%    % counting the number <<\{'
%    \item \label{i:algo2:StartLoop4} Проверить, что текущий символ является символом <<\}>>. Если ошибка, то перейти к шагу~\ref{i:algo2:AddLastSymbol4}.
%    \item Выполнить увеличение счетчика движения по строке и счетчик открывающихся скобок. Перейти к шагу~\ref{i:algo2:StartLoop4}.
%    % checking that nestings are numbers
%    \item \label{i:algo2:AddLastSymbol4} Выполнить проверку, что уровни вложенности являются числами. При ошибке перейти к шагу~\ref{i:algo2:nestingError2}.
%    \item Выполнить проверку, что текущий элемент строки равен символу <<\}>>. При успешном сравнении перейти к шагу~\ref{i:algo2:notNesting}.
%    \item Обнулить вспомогательную переменную \lstinline{p}, которая была объявлена в шаге~\ref{i:algo2:createVariables}.
%
%    \item \label{i:algo2:begin1} Проверить, что текущий символ не является символом <<\}>>, <<;>> и не последний в строке. Если ошибка, то перейти к шагу~\ref{i:algo2:AddLastSymbol5}.
%    \item Выполнить проверку, что текущий символ является цифрой. Если ошибка, то перейти к шагу~\ref{i:algo2:nestingError3}.
%    \item Выполнить проверку, что текущий элемент строки соответствует символу <<,>>. При ошибочном результате перейти к шагу~\ref{i:algo2:next}.
%    \item Выполнить проверку на то, что следующий символ входной строки является последним и соответствует числу. При ошибке перейти к шагу~\ref{i:algo2:nestingError4}.
%    \item Увеличить общий счетчик скобок, который был объявлен и проинициализирован в шаге~\ref{i:algo2:createVariables}.
%    \item Записать символ <<\textbackslash 0>> по индексу \lstinline{p}.
%    \item \label{i:algo2:subProg} Вызвать подпрограмму добавления уровней вложенности в список.
%    \item Проверить результат подпрограммы шага~\ref{i:algo2:subProg}. Если ошибка, то перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item Обнулить переменную <<p>>, увеличиваем счетчик движения по строке и перейти к шагу~\ref{i:algo2:begin1}.
%    \item \label{i:algo2:next} Выполнить перезапись символа уровня вложенности в массив \lstinline{nesting} и перейти к шагу~\ref{i:algo2:begin1}.
%    \item \label{i:algo2:AddLastSymbol5} Записать в конец массива символ <<\textbackslash 0>>.
%    \item \label{i:algo2:subProg1} Вызвать подпрограмму добавления уровней вложенности в список.
%    \item Проверить результат подпрограммы шага~\ref{i:algo2:subProg1}. Если ошибка, то перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    % checking that there is a <<}>> bracket
%    \item Выполнить проверку, что текущий элемент строки соответствует не символу <<\}>>. При успешном результате перейти к шагу~\ref{i:algo2:inc}.
%    \item \label{i:algo2:inc} Увеличить общий счетчик скобок и счетчик количества закрывающихся скобок \lstinline{close}, который был объявлен в шаге~\ref{i:algo2:createVariables}.
%    % counting the number of  <<}>> brackets
%    \item \label{i:algo2:Loop6} Проверить, что текущий символ является символом <<\}>>, не является символом <<;>> и не последний в строке. Если ошибка, то перейти к шагу~\ref{i:algo2:AddLastSymbol6}.
%    \item Увеличить счетчик количества закрывающихся скобок \lstinline{close}, который был объявлен в шаге~\ref{i:algo2:createVariables}, и счетчик движения по строке. Перейти к шагу~\ref{i:algo2:Loop6}.
%
%    \item \label{i:algo2:AddLastSymbol6} Выполнить проверку, что текущий элемент не является символом <<\{>> и
%    <<;>>. При успешном сравнении перейти к шагу~\ref{i:algo2:nestingError5}.
%    \item Уменьшить счетчик прохода по входной строке и увеличить счетчик уровней вложенности, который представлен глобальной переменной \lstinline{gooseVarsCount}.
%    \item Вызвать подпрограмму формирования строки для получения индекса переменной из общей модели данных для записи полученных значений.
%    \item Проверить результат подпрограммы предыдущего шага. Если ошибка, то перейти к шагу~\ref{i:algo2:errorIdx}.
%    \item Вызвать подпрограмму получения индекса переменной из общей модели данных для записи значений.
%    \item Проверить результат подпрограммы предыдущего шага. Если ошибка, то перейти к шагу~\ref{i:algo2:errorIdx1}.
%    \item Записать полученные данные в модуль \moduleDataStoring.
%    \item Выполнить проверку на существование локального списка. При ошибочной проверке перейти к шагу~\ref{i:algo2:continue}.
%    \item Добавить сформированный элемент в список. Обнулить необходимые поля структуры, которая является элементом списка.
%    \item \label{i:algo2:continue} Присвоить голове локального списка новый указатель и перейти к шагу~\ref{i:algo2:for}.
%    \item \label{i:algo2:lastOper} Выполнить проверку на соответствие счетчика открывающихся скобок и счетчика закрывающихся скобок. В случае ошибки перейти к шагу~\ref{i:algo2:lastError}.
%    \item Вернуть true и перейти к шагу~\ref{i:algo2:end}.
%    \item \label{i:algo2:nestingError} Вывести сообщение \texttt{Ошибка уровней вложенности. Пропущен символ <<\{>>} и перейти к шагу~\ref{i:algo2:endAlgorithm}.
%    \item \label{i:algo2:notG} Вывести сообщение \texttt{Текущий символ не является символом <<G>>. Ошибка} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:errorVarsFormat} Вывести сообщение \texttt{Ошибка vars формата} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:notCorrectSymbol} Вывести сообщение \texttt{Текущий символ не является символом <<.>>} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:errorVarsType} Вывести сообщение \texttt{Ошибка типа vars} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:invalidVarsFormat} Вывести сообщение \texttt{Некорректный формат vars. Ожидался символ <<,>>} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:nestingError1} Вывести сообщение \texttt{Ошибка уровней вложенности. Ожидается символ <<\{>>} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:nestingError2} Вывести сообщение \texttt{Ошибка уровней вложенности} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:notNesting} Вывести сообщение \texttt{Уровни вложенности отсутствуют} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:nestingError3} Вывести сообщение \texttt{Ошибка в символе уровня вложенности} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:nestingError4} Вывести сообщение \texttt{Ошибка в формате уровня вложенности} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:nestingError5} Вывести сообщение \texttt{Ошибка в концовке формата уровня вложенности} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:errorIdx} Вывести сообщение \texttt{Ошибка получения строки формирования индекса} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:errorIdx1} Вывести сообщение \texttt{Ошибка получения индекса} и перейти к шагу~\ref{i:algo2:freeConfigResources}.
%    \item \label{i:algo2:lastError} Вывести сообщение \texttt{Ошибка входной строки. Несоответствие количества открывающих и закрывающих скобок} и перейти к шагу~\ref{i:algo2:endAlgorithm}.
%
%    \item \label{i:algo2:freeConfigResources} Произвести очистку всех локальных списков.
%    \item \label{i:algo2:endAlgorithm} Вернуть false.
%    \item \label{i:algo2:end} Конец алгоритма.
%\end{enumerate_step}
%
%\subsection{Алгоритм приема и обработки GOOSE-пакета}
%
%Самым важным алгоритмом системы является алгоритм приема и обработки GOOSE-пакета. В нем осуществляется ожидание пакета, его прием, всевозможные проверки, вызов подпрограммы обработки и повторение вышеописанных действий.
%
%Распишем данный алгоритм по шагам:
%\begin{enumerate_step}
%    \item Начало алгоритма.
%    \item \label{i:pgp:createPointerStr} Создать указатель на структуру внутренних параметров модуля.
%    \item \label{i:pgp:createSocket} Вызвать подпрограмму создания сокета для организации приема GOOSE-пакета.
%    \item Выполнить проверку результата функции создания сокета. Если он некорректный, то перейти к шагу~\ref{i:pgp:socketHandleInvalid}.
%    \item Переписать в структуру внутренних параметров полученный и проверенный дескриптор сокета.
%    \item Выполнить получение индекса физического интерфейса из структуры внутренних параметров модуля.
%    \item Вызвать подпрограмму для связывания сокета с физическим интерфейсом, индекс которого был получен в предыдущем шаге.
%    \item Сравнить результат функции связывания со значением \lstinline{NET_OK}. Если они не равны, перейти к шагу~\ref{i:pgp:netSetSockOptError}.
%    \item Вызвать подпрограмму ожидания необходимости принимать производить прием пакетов.
%    \item Проинициализировать вспомогательные переменные для дальнейшей работы.
%    \item \label{i:pgp:processGoosePacket} Ожидать получение GOOSE-пакета.
%    \item Выполнить проверку на флаг остановки работы модуля. Если флаг установлен, то перейти к шагу~\ref{i:pgp:socketclose}.
%    \item Вызвать подпрограмму получения GOOSE-пакета.
%    \item Проверить количество полученных байт. Если оно не меньше нуля, перейти к шагу~\ref{i:pgp:netRecvNcOk}.
%    \item Вывести сообщение \texttt{Ошибка функции netRecvNc}.
%    \item Ожидать следующего такта системы и выполнить переход к шагу~\ref{i:pgp:processGoosePacket}.
%    \item \label{i:pgp:netRecvNcOk} Вызвать подпрограмму обработки полученного GOOSE-пакета.
%    \item Выполнить проверку результата обработки. Если он успешный, то перейти к шагу~\ref{i:pgp:parseOk}.
%    \item Вывести сообщение \texttt{Ошибка разбора GOOSE-пакета}.
%    \item \label{i:pgp:parseOk} Выполнить освобождение полученного пакета и перейти к шагу~\ref{i:pgp:processGoosePacket}.
%
%    \item \label{i:pgp:socketHandleInvalid} Вывести сообщение \texttt{Дескриптор сокета некорректный} и перейти к шагу~\ref{i:pgp:idTaskNull}.
%    \item \label{i:pgp:netSetSockOptError} Вывести сообщение \texttt{Ошибка функции netSetSockOpt}.
%    \item \label{i:pgp:socketclose} Выполнить закрытие и удаление созданного в шаге~\ref{i:pgp:createSocket} сокета.
%
%    \item \label{i:pgp:idTaskNull} В идентификатор задачи записать NULL.
%    \item \label{i:pgp:end} Конец алгоритма.
%\end{enumerate_step}
